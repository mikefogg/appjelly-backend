/**
 * Generate Evergreen Topics Job
 * Uses AI to generate timeless, evergreen topics for a curated topic category
 * These topics are rotated daily and don't expire
 */

import { CuratedTopic, TrendingTopic } from "#src/models/index.js";
import OpenAI from "openai";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export const JOB_GENERATE_EVERGREEN_TOPICS = "generate-evergreen-topics";

// Number of evergreen topics to generate per category
const TOPICS_PER_CATEGORY = 35; // 5 per day for 7-day rotation

/**
 * Use AI to generate evergreen topics for a category
 */
async function generateEvergreenTopics(curatedTopic) {
  try {
    const prompt = `Generate ${TOPICS_PER_CATEGORY} evergreen, timeless topics for the "${curatedTopic.name}" category that would help someone grow their platform on social media.

Category: ${curatedTopic.name}
Description: ${curatedTopic.description}

These topics should be:
- NOT tied to current events, news, or time-sensitive information
- Actionable strategies, frameworks, tips, or thought-provoking ideas
- Engaging and conversation-starting
- Suitable for a Twitter/X post (can be expanded into threads)
- Diverse in approach (some tactical, some strategic, some philosophical)

For each topic, provide:
1. topic_name: A clear, engaging topic (max 100 chars)
2. context: A brief description/angle for the topic (1-2 sentences)

Return ONLY a JSON object with this structure:
{
  "topics": [
    {
      "topic_name": "Content repurposing strategies for maximum reach",
      "context": "How to turn one piece of content into 10 different formats across platforms. Focus on efficiency and amplification."
    },
    {
      "topic_name": "Email list building tactics that actually convert",
      "context": "Lead magnets and opt-in strategies that turn visitors into subscribers. Share what works in 2024."
    }
  ]
}`;

    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      response_format: { type: "json_object" },
      messages: [
        {
          role: "system",
          content: "You are an expert in social media growth, content strategy, and digital marketing. Generate timeless, actionable topics that help people grow their platform."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 3000,
    });

    const result = JSON.parse(response.choices[0].message.content);
    return result.topics || [];

  } catch (error) {
    console.error(`[Generate Evergreen Topics] AI generation failed:`, error.message);
    throw error;
  }
}

export default async function generateEvergreenTopicsJob(job) {
  const { curatedTopicId } = job.data;

  console.log(`[Generate Evergreen Topics] Starting generation for topic: ${curatedTopicId}`);

  try {
    // Get curated topic
    const topic = await CuratedTopic.query().findById(curatedTopicId);

    if (!topic) {
      throw new Error(`Curated topic ${curatedTopicId} not found`);
    }

    if (topic.topic_type !== 'evergreen') {
      console.log(`[Generate Evergreen Topics] Topic "${topic.name}" is not evergreen type, skipping`);
      return { success: true, message: 'Topic is not evergreen type' };
    }

    console.log(`[Generate Evergreen Topics] Generating topics for "${topic.name}" (${topic.slug})`);

    // Check if we already have evergreen topics for this category
    const existingCount = await TrendingTopic.query()
      .where('curated_topic_id', curatedTopicId)
      .where('topic_type', 'evergreen')
      .resultSize();

    if (existingCount >= TOPICS_PER_CATEGORY) {
      console.log(`[Generate Evergreen Topics] Already have ${existingCount} evergreen topics, skipping`);
      return { success: true, message: 'Already have sufficient evergreen topics', count: existingCount };
    }

    // Generate topics with AI
    console.log(`[Generate Evergreen Topics] Generating ${TOPICS_PER_CATEGORY} topics with AI...`);
    const generatedTopics = await generateEvergreenTopics(topic);

    if (generatedTopics.length === 0) {
      throw new Error('No topics generated by AI');
    }

    console.log(`[Generate Evergreen Topics] AI generated ${generatedTopics.length} topics`);

    // Assign rotation groups (1-7 for days of week)
    // Distribute evenly across the 7 days
    const topicsWithRotation = generatedTopics.map((t, index) => ({
      curated_topic_id: curatedTopicId,
      topic_name: t.topic_name,
      context: t.context,
      topic_type: 'evergreen',
      rotation_group: (index % 7) + 1, // 1-7
      sort_order: Math.floor(index / 7), // Order within the day
      mention_count: 0,
      total_engagement: 0,
      detected_at: new Date().toISOString(),
      expires_at: null, // Evergreen topics don't expire
    }));

    // Insert into database
    await TrendingTopic.query().insert(topicsWithRotation);

    console.log(`[Generate Evergreen Topics] Successfully inserted ${topicsWithRotation.length} evergreen topics`);

    // Update topic's last_digested_at to mark generation
    await topic.$query().patch({
      last_digested_at: new Date().toISOString(),
    });

    return {
      success: true,
      topicId: curatedTopicId,
      topicName: topic.name,
      topicsGenerated: topicsWithRotation.length,
      rotationGroups: {
        1: topicsWithRotation.filter(t => t.rotation_group === 1).length,
        2: topicsWithRotation.filter(t => t.rotation_group === 2).length,
        3: topicsWithRotation.filter(t => t.rotation_group === 3).length,
        4: topicsWithRotation.filter(t => t.rotation_group === 4).length,
        5: topicsWithRotation.filter(t => t.rotation_group === 5).length,
        6: topicsWithRotation.filter(t => t.rotation_group === 6).length,
        7: topicsWithRotation.filter(t => t.rotation_group === 7).length,
      }
    };

  } catch (error) {
    console.error(`[Generate Evergreen Topics] Error:`, error);
    throw error;
  }
}
