import { beforeAll, afterAll, beforeEach, vi } from "vitest";
import { knex } from "#src/models/index.js";

// Global Clerk authentication mock
vi.mock("@clerk/express", () => ({
  clerkMiddleware: () => (req, res, next) => {
    req.auth = () => ({ userId: req.headers["x-test-user-id"] || null });
    next();
  },
  requireAuth: () => (req, res, next) => {
    if (!req.headers["x-test-user-id"]) {
      return res.status(401).json({ error: { message: "Unauthorized", code: 401 } });
    }
    req.auth = () => ({ userId: req.headers["x-test-user-id"] });
    next();
  },
}));

// Global OpenAI mock
vi.mock("openai", () => ({
  default: vi.fn().mockImplementation(() => ({
    chat: {
      completions: {
        create: vi.fn().mockImplementation((params) => {
          // Always return a valid response with choices array
          return Promise.resolve({
            choices: [{
              message: {
                content: JSON.stringify({
                  characters: [
                    {
                      name: "Emma",
                      matchedActorIds: [],
                      type: "child",
                      isNew: true,
                      relationships: {}
                    }
                  ],
                  ambiguousMatches: [],
                  pages: [
                    { page_number: 1, text: "Once upon a time...", image_prompt: "A magical forest" },
                    { page_number: 2, text: "And they lived happily ever after.", image_prompt: "A sunset" }
                  ]
                })
              }
            }]
          });
        })
      }
    },
    moderations: {
      create: vi.fn().mockResolvedValue({
        results: [{
          flagged: false,
          categories: {},
          category_scores: {}
        }]
      })
    }
  }))
}));

// Mock external Cloudflare API
global.fetch = vi.fn();

beforeAll(async () => {
  // Run migrations on test database
  await knex.migrate.latest();
});

beforeEach(async () => {
  // Clean all tables before each test
  await knex.raw(`
    TRUNCATE TABLE 
      apps, 
      accounts, 
      account_links, 
      actors, 
      media, 
      inputs, 
      artifacts, 
      artifact_pages, 
      shared_views, 
      subscriptions 
    RESTART IDENTITY CASCADE
  `);

  // Reset and configure fetch mock for external APIs
  vi.clearAllMocks();
  
  global.fetch.mockImplementation((url, options) => {
    // Mock Cloudflare Images API
    if (url.includes('cloudflare.com/client/v4/accounts')) {
      if (url.includes('/images/v2/direct_upload')) {
        // Direct upload URL generation - auto-generate ID like Cloudflare does
        const autoGeneratedId = `cf-${Math.random().toString(36).substring(2, 15)}`;
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({
            success: true,
            result: {
              uploadURL: "https://upload.imagedelivery.net/test-upload-url",
              id: autoGeneratedId
            }
          })
        });
      } else if (url.includes('/token')) {
        // Signed URL token generation
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({
            success: true,
            result: {
              token: "test-signed-token"
            }
          })
        });
      } else if (url.includes('/images/v1') && options?.method === 'POST') {
        // Image upload
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({
            success: true,
            result: {
              id: "test-image-key",
              variants: ["public"]
            }
          })
        });
      } else if (url.includes('/images/v1') && options?.method === 'DELETE') {
        // Image deletion
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({
            success: true
          })
        });
      }
    }
    
    // Default fallback
    return Promise.reject(new Error(`Unmocked fetch call to ${url}`));
  });
});

afterAll(async () => {
  // Close database connection
  await knex.destroy();
});